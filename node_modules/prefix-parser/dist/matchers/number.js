"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FloatArg = exports.IntegerArg = void 0;
const utils_1 = require("../utils");
const base_1 = __importDefault(require("./base"));
/** Matches the next valid number using 'parseInt' and 'parseFloat' for the respective type. */
class NumberArg extends base_1.default {
    constructor(...[name, opts = {}]) {
        super(name);
        const { min, max, float = false } = opts;
        if (utils_1.isPopulated(min))
            utils_1.assert(utils_1.isNum(min), `Value '${min}' must be a number`);
        if (utils_1.isPopulated(max))
            utils_1.assert(utils_1.isNum(max), `Value '${max}' must be a number`);
        if (utils_1.isPopulated(min) && utils_1.isPopulated(max))
            utils_1.assert(min < max, `Min value '${min}' must be less than '${max}'`);
        this.float = float;
        this.min = (float || utils_1.isVoid(min)) ? min : Math.floor(min);
        this.max = (float || utils_1.isVoid(max)) ? max : Math.floor(max);
    }
    parse(text) {
        const re = /^-?[\d\.]+/g; // Look for numbers like -5, 5, -5.0, 5.0
        const matches = text.trim().match(re);
        if (!matches)
            throw Error(); // not found
        const match = matches[0];
        const rest = text.replace(match, '').trim();
        const value = this.float ? parseFloat(match) : parseInt(match);
        if (value === NaN)
            throw Error(`Number '${match}' could not be parsed as a number.`);
        if (this.min !== null && value < this.min)
            throw Error(`'${match}' cannot be less than '${this.min}'`);
        if (this.max !== null && value > this.max)
            throw Error(`'${match}' cannot be more than '${this.max}'`);
        return [value, rest];
    }
    help() {
        const type = this.float ? 'float' : 'int';
        const hasMin = utils_1.isNum(this.min), hasMax = utils_1.isNum(this.max);
        const hasBoth = hasMin && hasMax;
        const extra = hasBoth ? ` ${this.min}~${this.max}`
            : hasMin ? ` >${this.min}`
                : hasMax ? ` <${this.max}`
                    : '';
        return `${this.name} {${type}${extra}}`;
    }
    example() {
        const min = this.min ?? 0;
        const max = this.max ?? 100;
        return Math.floor((min + max) / 2).toString();
    }
}
/** Matches an integer. Numbers like '12.34' will be converted to an int like '12'. */
class IntegerArg extends NumberArg {
    constructor(...[name, opts]) {
        super(name, { ...opts, float: false });
    }
}
exports.IntegerArg = IntegerArg;
/** Matches a float. */
class FloatArg extends NumberArg {
    constructor(...[name, opts]) {
        super(name, { ...opts, float: true });
    }
    example() {
        const min = this.min ?? 0.0;
        const max = this.max ?? 100.0;
        return ((min + max) / 2).toFixed(2);
    }
}
exports.FloatArg = FloatArg;
