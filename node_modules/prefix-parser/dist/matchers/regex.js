"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegexArg = void 0;
const utils_1 = require("../utils");
const base_1 = __importDefault(require("./base"));
/** A generic regex parser which can match regex and extract a single regex group. */
class RegexArg extends base_1.default {
    /**
     * @param name - The name of the command.
     * @param regex - The regex to match with. Everything matched by this expression will be discarded and not accessible by remaining argument parsers.
     * @param group - The index of a regex group to return. The
     */
    constructor(...[name, regex, example, opts = {}]) {
        super(name);
        const { group = 0 } = opts;
        utils_1.assertPositive(group);
        this.regex = regex;
        this._example = example;
        this.group = utils_1.intArg(group);
    }
    parse(text) {
        const matches = text.trim().match(this.regex);
        if (!matches)
            throw Error(); // not found
        if (this.group >= matches.length)
            throw Error(`Could not get group '${this.group}' from ${matches.length} matches`);
        const allMatch = matches[0];
        const groupMatch = matches[this.group].trim();
        const rest = text.replace(allMatch, '').trim();
        return [groupMatch, rest];
    }
    help() {
        return `\`${this.name} {text}\``;
    }
    /** Returns an example of this argument as seen by end users via the help flag. */
    example() {
        return this._example;
    }
}
exports.RegexArg = RegexArg;
